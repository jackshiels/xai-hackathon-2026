<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grok Voice Agent (Debug Mode)</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.7/dist/bundle.min.js"></script>
    
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; max-width: 900px; margin: 40px auto; padding: 20px; background: #f0f2f5; color: #1a1a1a; }
        .container { background: white; padding: 30px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        h1 { margin-top: 0; color: #111; font-size: 24px; margin-bottom: 25px; }
        
        /* Status Bar */
        .status-bar { display: flex; align-items: center; justify-content: space-between; margin-bottom: 25px; background: #f8f9fa; padding: 12px 20px; border-radius: 10px; border: 1px solid #e9ecef; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; margin-right: 10px; display: inline-block; }
        .status-text { font-weight: 600; font-size: 14px; color: #444; }
        
        .disconnected .status-dot { background: #dc3545; }
        .connecting .status-dot { background: #ffc107; }
        .listening .status-dot { background: #28a745; animation: pulse 2s infinite; }
        .speaking .status-dot { background: #fd7e14; }
        .responding .status-dot { background: #007bff; }

        /* Transcript */
        .transcript { 
            background: #fff; border: 1px solid #eee; border-radius: 12px; 
            height: 400px; overflow-y: auto; padding: 20px; margin-bottom: 20px;
            display: flex; flex-direction: column; gap: 15px;
        }
        .msg { display: flex; flex-direction: column; max-width: 85%; }
        .msg.user { align-self: flex-end; align-items: flex-end; }
        .msg.assistant { align-self: flex-start; align-items: flex-start; }
        
        .bubble { padding: 10px 16px; border-radius: 12px; font-size: 15px; line-height: 1.5; }
        .user .bubble { background: #007bff; color: white; border-bottom-right-radius: 2px; }
        .assistant .bubble { background: #f1f3f5; color: #1a1a1a; border-bottom-left-radius: 2px; }

        /* Debug Panel */
        .debug-panel { margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px; font-size: 12px; display: none; }
        .debug-log { height: 150px; overflow-y: auto; background: #1e1e1e; color: #0f0; padding: 10px; margin-top: 5px; font-family: monospace; border-radius: 6px; }
        .log-entry { border-bottom: 1px solid #333; padding: 2px 0; }
        .error { background: #fee; color: #c33; padding: 12px; border-radius: 8px; display: none; margin-top: 10px; font-weight: 500; }

        .controls { margin-top: 20px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Grok Voice Agent</h1>

        <div id="statusBox" class="status-bar disconnected">
            <div><span class="status-dot"></span><span id="statusText">Disconnected</span></div>
            <div style="font-size:12px; color:#888;" id="micStatus">(Mic Inactive)</div>
        </div>

        <div style="margin-bottom:15px; display:flex; gap:10px;">
            <input type="text" id="backendUrl" value="http://localhost:8000" placeholder="Backend URL" style="flex:1; padding:8px;">
            <select id="voiceSelect" style="padding:8px;">
                <option value="Ara">Ara (Female)</option>
                <option value="Rex">Rex (Male)</option>
            </select>
        </div>

        <div id="transcript" class="transcript"></div>
        <div id="errorBox" class="error"></div>

        <div class="controls">
            <button id="connectBtn" onclick="connect()">Start Conversation</button>
            <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
        </div>

        <div style="margin-top: 15px;">
            <label><input type="checkbox" id="showDebug" onchange="toggleDebug()"> Show Debug Logs</label>
        </div>
        <div id="debugPanel" class="debug-panel">
            <strong>Server Events & Audio Logs:</strong>
            <div id="debugLog" class="debug-log"></div>
        </div>
    </div>

    <script>
        // --- Config ---
        const SAMPLE_RATE = 24000;
        
        // --- State ---
        let ws = null;
        let vadInstance = null;
        let audioContext = null;
        let audioPlayer = null;
        
        // --- Debugger ---
        function logDebug(type, msg) {
            if (!document.getElementById('showDebug').checked) return;
            const log = document.getElementById('debugLog');
            const div = document.createElement('div');
            div.className = 'log-entry';
            div.textContent = `[${new Date().toLocaleTimeString()}] [${type}] ${msg}`;
            log.prepend(div);
        }

        function toggleDebug() {
            document.getElementById('debugPanel').style.display = 
                document.getElementById('showDebug').checked ? 'block' : 'none';
        }

        // --- Audio Player ---
        class AudioStreamPlayer {
            constructor(context) {
                this.context = context;
                this.queue = [];
                this.nextStartTime = 0;
                this.isPlaying = false;
            }

            addPCM16(base64) {
                try {
                    // 1. Decode Base64
                    const binary = atob(base64);
                    // 2. Validate length (Must be even for Int16)
                    if (binary.length % 2 !== 0) {
                        logDebug("AUDIO_ERR", "Odd byte length, skipping frame");
                        return;
                    }
                    
                    const bytes = new Uint8Array(binary.length);
                    for (let i=0; i<binary.length; i++) bytes[i] = binary.charCodeAt(i);
                    
                    // 3. Convert to Float32
                    const pcm16 = new Int16Array(bytes.buffer);
                    const float32 = new Float32Array(pcm16.length);
                    for (let i=0; i<pcm16.length; i++) float32[i] = pcm16[i] / 32768.0;
                    
                    logDebug("AUDIO", `Queued ${float32.length} samples`);
                    
                    // 4. Create Buffer
                    const buffer = this.context.createBuffer(1, float32.length, SAMPLE_RATE);
                    buffer.getChannelData(0).set(float32);
                    
                    this.queue.push(buffer);
                    this.schedule();
                } catch(e) { 
                    logDebug("AUDIO_ERR", e.message);
                }
            }

            schedule() {
                if (this.queue.length === 0 || this.isPlaying) return;
                this.isPlaying = true;
                const buffer = this.queue.shift();
                const src = this.context.createBufferSource();
                src.buffer = buffer;
                src.connect(this.context.destination);
                
                const now = this.context.currentTime;
                // Sync fix: If we fell behind, jump to now
                if (this.nextStartTime < now) this.nextStartTime = now;
                
                src.start(this.nextStartTime);
                this.nextStartTime += buffer.duration;
                
                src.onended = () => {
                    this.isPlaying = false;
                    this.schedule();
                };
            }
            
            reset() {
                this.queue = [];
                this.isPlaying = false;
                this.nextStartTime = 0;
            }
        }

        // --- UI ---
        function setStatus(state, text) {
            const el = document.getElementById('statusBox');
            el.className = `status-bar ${state}`;
            document.getElementById('statusText').textContent = text;
        }

        function appendMessage(role, text, isStream = false) {
            const t = document.getElementById('transcript');
            if (role === 'assistant' && isStream) {
                const lastMsg = t.lastElementChild;
                if (lastMsg && lastMsg.classList.contains('assistant')) {
                    lastMsg.querySelector('.bubble').textContent += text;
                    t.scrollTop = t.scrollHeight;
                    return;
                }
            }
            const div = document.createElement('div');
            div.className = `msg ${role}`;
            div.innerHTML = `<div class="bubble">${text}</div>`;
            t.appendChild(div);
            t.scrollTop = t.scrollHeight;
        }

        // --- Core ---
        async function connect() {
            const btn = document.getElementById('connectBtn');
            const url = document.getElementById('backendUrl').value;
            const voice = document.getElementById('voiceSelect').value;
            
            btn.disabled = true;
            setStatus('connecting', 'Authenticating...');
            document.getElementById('errorBox').style.display = 'none';

            try {
                // 1. Token
                const res = await fetch(`${url}/session`, { method: 'POST' });
                if (!res.ok) throw new Error("Auth Failed");
                const data = await res.json();
                const token = data.client_secret?.value || data.token || data.value;

                // 2. Audio
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                await audioContext.resume();
                audioPlayer = new AudioStreamPlayer(audioContext);
                logDebug("SYS", "Audio Context Started");

                // 3. WS
                ws = new WebSocket(
                    `wss://api.x.ai/v1/realtime?model=grok-beta-realtime`,
                    [ "realtime", `openai-insecure-api-key.${token}` ]
                );

                ws.onopen = async () => {
                    logDebug("WS", "Connected");
                    ws.send(JSON.stringify({
                        type: 'session.update',
                        session: {
                            modalities: ["text", "audio"],
                            instructions: "You are a helpful AI.",
                            voice: voice,
                            input_audio_format: "pcm16",
                            output_audio_format: "pcm16",
                            turn_detection: null,
                            input_audio_transcription: { model: "whisper-1" }
                        }
                    }));
                    
                    await initVAD();
                    setStatus('listening', 'Connected');
                    document.getElementById('micStatus').textContent = "(Listening...)";
                    document.getElementById('disconnectBtn').disabled = false;
                };

                ws.onmessage = (e) => {
                    const msg = JSON.parse(e.data);
                    
                    // --- UNIVERSAL EVENT HANDLER ---
                    // Handle both standard "audio" and Grok "output_audio"
                    if (msg.type.endsWith('audio.delta')) {
                        logDebug("RX_AUDIO", `Received ${msg.delta.length} chars`);
                        if (audioPlayer) audioPlayer.addPCM16(msg.delta);
                    }
                    else if (msg.type.endsWith('transcript.delta') || msg.type.endsWith('text.delta')) {
                        appendMessage('assistant', msg.delta, true);
                    }
                    else if (msg.type === 'response.created') {
                        setStatus('responding', 'Grok speaking...');
                        appendMessage('assistant', '', true);
                    }
                    else if (msg.type === 'response.done') {
                        setStatus('listening', 'Listening...');
                    }
                    else if (msg.type === 'conversation.item.input_audio_transcription.completed') {
                        if (msg.transcript) appendMessage('user', msg.transcript);
                    }
                    else if (msg.type === 'error') {
                        logDebug("ERR", msg.error.message);
                    }
                };

            } catch (err) {
                console.error(err);
                document.getElementById('errorBox').textContent = err.message;
                document.getElementById('errorBox').style.display = 'block';
                btn.disabled = false;
            }
        }

        async function initVAD() {
            vadInstance = await vad.MicVAD.new({
                positiveSpeechThreshold: 0.8,
                onSpeechStart: () => {
                    if (audioPlayer) audioPlayer.reset();
                    setStatus('speaking', 'Speaking...');
                },
                onSpeechEnd: (audio) => {
                    setStatus('responding', 'Processing...');
                    const pcm16 = floatTo16BitPCM(audio);
                    const base64 = btoa(String.fromCharCode(...new Uint8Array(pcm16)));
                    if (ws && ws.readyState === 1) {
                        ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: base64 }));
                        ws.send(JSON.stringify({ type: 'input_audio_buffer.commit' }));
                    }
                },
                sampleRate: SAMPLE_RATE,
                audioContext: audioContext
            });
            vadInstance.start();
        }

        function floatTo16BitPCM(float32Arr) {
            const pcm16 = new Int16Array(float32Arr.length);
            for (let i = 0; i < float32Arr.length; i++) {
                let s = Math.max(-1, Math.min(1, float32Arr[i]));
                pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return pcm16.buffer;
        }

        function disconnect() {
            if (ws) ws.close();
            if (vadInstance) vadInstance.destroy();
            if (audioContext) audioContext.close();
            setStatus('disconnected', 'Disconnected');
            document.getElementById('connectBtn').disabled = false;
        }
    </script>
</body>
</html>